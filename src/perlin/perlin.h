#ifndef PERLIN_H
#define PERLIN_H

#include <stdlib.h>
#include <math.h>
#include <string.h>

namespace perlin
{

class Noise1D
{
public:

	Noise1D( int* indicies, float* gradients, float positionOffset )
	 : m_indicies( indicies ), 
	   m_positionOffset( positionOffset ),
	   m_gradients( gradients ) {} 

	~Noise1D()
	{
		delete m_indicies;
		delete m_gradients;
	}

	float generate( float x ) const
	{
		x += m_positionOffset;

		int xCoord = floor( x );


		/*
		Using:
				
		   a --x----- b

		 ---> x
		*/

		float offset = x - xCoord;

		int a = xCoord;
		int b = xCoord + 1;

		float aGrad = getGradient( a );
		float bGrad = getGradient( b );

		float aContrib = offset * aGrad;
		float bContrib = ( offset - 1 ) * bGrad;

		float param = 3 * offset * offset - 2 * offset * offset * offset;

		return ( 1 - param ) * aContrib + param * bContrib;
	}

	float getGradient( int x ) const
	{
		/*
		Offsets as generated by the following python code:

			import random

			values = [ str( x ) for x in range( 0, 256 ) ]

			random.seed( 0 )
			random.shuffle( values )

			print "{ %s }" % ", ".join( values )

		*/

		int index = x & 255;
		return m_gradients[ m_indicies[ index ] ];
	}


private:

	int* m_indicies;
	float m_positionOffset;
	float* m_gradients;

};

template< typename T >
class Point2
{
public:

	Point2() {};
	Point2( T _x, T _y ) : x( _x ), y( _y ) {}

    T dot( const Point2< T >& other ) const
	{
		return x * other.x + y * other.y;
	}

	T lengthSq() const
	{
		return x * x + y * y;
	}

	Point2< T > operator-( const Point2& other ) const
	{
		return Point2< T >( x - other.x, y - other.y );
	}

	Point2< T > operator+( const Point2& other ) const
	{
		return Point2< T >( x + other.x, y + other.y );
	}

	template< typename S >
	Point2< T > operator*( const S& scalar ) const
	{
		return Point2< T >( x * scalar, y * scalar );
	}

	T x;
	T y;
};

typedef Point2< int > IntPoint2;
typedef Point2< float > FloatPoint2;

class Noise2D
{
public:

	Noise2D( int* indicies, FloatPoint2* gradients, FloatPoint2& positionOffset )
	 : m_indicies( indicies ),
	   m_positionOffset( positionOffset ),
	   m_gradients( gradients ) {} 

	~Noise2D()
	{
		delete m_indicies;
		delete m_gradients;
	}


	float generate( float x, float y ) const
	{
		x += m_positionOffset.x;
		y += m_positionOffset.y;

		const int xCoord = floor( x );
		const int yCoord = floor( y );

		/*
		Using:
		    
		       d ---------- c
		       |            |
		       |  . (x,y)   |
		 y     |            |
		 ^     |            |
		 |     a ---------- b
		 |
		  ---> x
		 
		 */

		const IntPoint2 a( xCoord, yCoord );
		const IntPoint2 b( xCoord + 1, yCoord );
		const IntPoint2 c( xCoord + 1, yCoord + 1 );
		const IntPoint2 d( xCoord, yCoord + 1 );

		const FloatPoint2 aGrad = getGradient( a );
		const FloatPoint2 bGrad = getGradient( b );
		const FloatPoint2 cGrad = getGradient( c );
		const FloatPoint2 dGrad = getGradient( d );

		float xOffset = x - xCoord;
		float yOffset = y - yCoord;

		const FloatPoint2 aOffset( xOffset, yOffset );
		const FloatPoint2 bOffset( xOffset - 1, yOffset );
		const FloatPoint2 cOffset( xOffset - 1, yOffset - 1 );
		const FloatPoint2 dOffset( xOffset, yOffset - 1 );

		float aContrib = aGrad.dot( aOffset );
		float bContrib = bGrad.dot( bOffset );
		float cContrib = cGrad.dot( cOffset );
		float dContrib = dGrad.dot( dOffset );

		float xOffsetSq = xOffset * xOffset;
		float yOffsetSq = yOffset * yOffset;

		float xParam = 3 * xOffsetSq - 2 * xOffsetSq * xOffset;
		float yParam = 3 * yOffsetSq - 2 * yOffsetSq * yOffset;

		float abContrib = ( 1 - xParam ) * aContrib + xParam * bContrib;
		float dcContrib = ( 1 - xParam ) * dContrib + xParam * cContrib;

		return ( 1 - yParam ) * abContrib + yParam * dcContrib;
	}

	FloatPoint2 getGradient( const IntPoint2& point ) const
	{
		int index = point.y & 255;
		index = ( point.x + m_indicies[ index ] ) & 255;

		return m_gradients[ index ];
	}

private:

	int* m_indicies;
	FloatPoint2 m_positionOffset;
	FloatPoint2* m_gradients;
};

template< typename T >
class Point3
{
public:

	Point3() {};
	Point3( T _x, T _y, T _z ) : x( _x ), y( _y ), z( _z ) {}

    T dot( const Point3< T >& other ) const
	{
		return x * other.x + y * other.y + z * other.z;
	}

	T x;
	T y;
	T z;
};

typedef Point3< int > IntPoint3;
typedef Point3< float > FloatPoint3;


class Noise3D
{
public:

	Noise3D( int* indicies, FloatPoint3* gradients, FloatPoint3& positionOffset )
	 : m_indicies( indicies ), 
	   m_positionOffset( positionOffset ),
	   m_gradients( gradients ) {} 

	~Noise3D()
	{
		delete m_indicies;
		delete m_gradients;
	}

	float generate( float x, float y, float z ) const
	{
		x += m_positionOffset.x;
		y += m_positionOffset.y;
		z += m_positionOffset.z;

		int xCoord = floor( x );
		int yCoord = floor( y );
		int zCoord = floor( z );

		/*
		Using:
		           v ---------- u 
		          /|           /| 
		         / |   (x,y,z)/ |
		        /  |  .      /  |
		       d ---------- c   |
		       |   s -------|-- t
		       |  /         |  /
		 y     | /          | /
		 ^  z  |/           |/
		 | Â¬   a ---------- b
		 |/
		  ---> x
		 
		 */

		IntPoint3 a( xCoord, yCoord, zCoord );
		IntPoint3 b( xCoord + 1, yCoord, zCoord );
		IntPoint3 c( xCoord + 1, yCoord + 1, zCoord );
		IntPoint3 d( xCoord, yCoord + 1, zCoord );

		IntPoint3 s( xCoord, yCoord, zCoord + 1 );
		IntPoint3 t( xCoord + 1, yCoord, zCoord + 1 );
		IntPoint3 u( xCoord + 1, yCoord + 1, zCoord + 1 );
		IntPoint3 v( xCoord, yCoord + 1, zCoord + 1 );

		FloatPoint3 aGrad = getGradient( a );
		FloatPoint3 bGrad = getGradient( b );
		FloatPoint3 cGrad = getGradient( c );
		FloatPoint3 dGrad = getGradient( d );

		FloatPoint3 sGrad = getGradient( s );
		FloatPoint3 tGrad = getGradient( t );
		FloatPoint3 uGrad = getGradient( u );
		FloatPoint3 vGrad = getGradient( v );

		float xOffset = x - xCoord;
		float yOffset = y - yCoord;
		float zOffset = z - zCoord;

		FloatPoint3 aOffset( xOffset, yOffset, zOffset );
		FloatPoint3 bOffset( xOffset - 1, yOffset, zOffset );
		FloatPoint3 cOffset( xOffset - 1, yOffset - 1, zOffset );
		FloatPoint3 dOffset( xOffset, yOffset - 1, zOffset );

		FloatPoint3 sOffset( xOffset, yOffset, zOffset - 1 );
		FloatPoint3 tOffset( xOffset - 1, yOffset, zOffset - 1 );
		FloatPoint3 uOffset( xOffset - 1, yOffset - 1, zOffset - 1 );
		FloatPoint3 vOffset( xOffset, yOffset - 1, zOffset - 1 );

		float aContrib = aGrad.dot( aOffset );
		float bContrib = bGrad.dot( bOffset );
		float cContrib = cGrad.dot( cOffset );
		float dContrib = dGrad.dot( dOffset );

		float sContrib = sGrad.dot( sOffset );
		float tContrib = tGrad.dot( tOffset );
		float uContrib = uGrad.dot( uOffset );
		float vContrib = vGrad.dot( vOffset );

		float xParam = 3 * xOffset * xOffset - 2 * xOffset * xOffset * xOffset;
		float yParam = 3 * yOffset * yOffset - 2 * yOffset * yOffset * yOffset;
		float zParam = 3 * zOffset * zOffset - 2 * zOffset * zOffset * zOffset;

		float abContrib = ( 1 - xParam ) * aContrib + xParam * bContrib;
		float dcContrib = ( 1 - xParam ) * dContrib + xParam * cContrib;

		float stContrib = ( 1 - xParam ) * sContrib + xParam * tContrib;
		float vuContrib = ( 1 - xParam ) * vContrib + xParam * uContrib;

		float abcdContrib = ( 1 - yParam ) * abContrib + yParam * dcContrib;
		float stuvContrib = ( 1 - yParam ) * stContrib + yParam * vuContrib;

		return ( 1 - zParam ) * abcdContrib + zParam * stuvContrib;
	}

	FloatPoint3 getGradient( IntPoint3 point ) const
	{
		int index = point.z & 255;
		index = ( point.y + m_indicies[ index ] ) & 255;
		index = ( point.x + m_indicies[ index ] ) & 255;

		return m_gradients[ index ];
	}

private:

	int* m_indicies;
	FloatPoint3 m_positionOffset;
	FloatPoint3* m_gradients;

};


class NoiseFactory
{
public:

	NoiseFactory() {};


	Noise1D* create1D() const
	{
		float* gradients = new float[ 256 ];

		for ( int i=0; i<256; ++i )
		{
			gradients[ i ] = drand48() > 0.5 ? 1.0 : -1.0;
		}

		/*
		Offsets as generated by the following python code:

			import random
			values = [ str( x ) for x in range( 0, 256 ) ]
			random.seed( 0 )
			random.shuffle( values )
			print "{ %s }" % ", ".join( values )

		*/
		int P[256] = { 62, 211, 5, 167, 9, 20, 189, 30, 224, 93, 176, 110,
			155, 214, 50, 238, 81, 114, 104, 90, 151, 169, 160, 103, 197, 66,
			89, 85, 127, 55, 201, 172, 141, 10, 92, 70, 44, 163, 217, 212, 209,
			7, 125, 57, 36, 237, 254, 142, 97, 153, 227, 61, 27, 8, 146, 115,
			244, 173, 240, 252, 202, 162, 236, 56, 24, 42, 205, 135, 175, 215,
			74, 29, 198, 122, 46, 48, 188, 79, 88, 190, 77, 19, 251, 138, 206,
			63, 1, 133, 233, 140, 32, 28, 170, 53, 38, 45, 180, 43, 59, 25,
			184, 181, 69, 168, 255, 71, 18, 229, 204, 80, 39, 22, 152, 11, 131,
			245, 145, 41, 178, 249, 31, 12, 134, 132, 117, 100, 26, 15, 230,
			124, 2, 4, 154, 148, 52, 78, 83, 239, 220, 177, 248, 129, 82, 6,
			250, 199, 14, 182, 207, 119, 33, 17, 111, 37, 130, 166, 76, 96, 13,
			126, 147, 174, 196, 235, 95, 157, 98, 150, 143, 137, 47, 221, 67,
			94, 161, 226, 241, 164, 156, 136, 203, 86, 120, 191, 34, 35, 54,
			108, 72, 113, 84, 112, 116, 186, 105, 232, 225, 228, 231, 21, 187,
			102, 64, 16, 91, 165, 200, 49, 247, 40, 242, 243, 51, 185, 253, 0,
			246, 222, 87, 158, 3, 121, 179, 58, 194, 107, 219, 208, 139, 99,
			23, 109, 159, 210, 171, 73, 213, 192, 234, 218, 60, 149, 183, 68,
			123, 223, 144, 118, 75, 195, 101, 128, 65, 106, 193, 216 };

		int* indicies = new int[ 256 ];

		memcpy( indicies, P, sizeof( int ) * 256 );

		return new Noise1D( indicies, gradients, gradients[ 0 ] );
	}


	Noise2D* create2D() const
	{
		FloatPoint2* gradients = new FloatPoint2[ 256 ];

		for ( int i=0; i<256; ++i )
		{
			gradients[ i ].x = drand48() * 2.0 - 1.0;
			gradients[ i ].y = drand48() * 2.0 - 1.0;

			float lengthSq = gradients[ i ].x * gradients[ i ].x + gradients[ i ].y * gradients[ i ].y;
			float length = sqrt( lengthSq );

			gradients[ i ].x /= length;
			gradients[ i ].y /= length;
		}

		/*
		Offsets as generated by the following python code:

			import random
			values = [ str( x ) for x in range( 0, 256 ) ]
			random.seed( 0 )
			random.shuffle( values )
			print "{ %s }" % ", ".join( values )

		*/
		int P[256] = { 62, 211, 5, 167, 9, 20, 189, 30, 224, 93, 176, 110,
			155, 214, 50, 238, 81, 114, 104, 90, 151, 169, 160, 103, 197, 66,
			89, 85, 127, 55, 201, 172, 141, 10, 92, 70, 44, 163, 217, 212, 209,
			7, 125, 57, 36, 237, 254, 142, 97, 153, 227, 61, 27, 8, 146, 115,
			244, 173, 240, 252, 202, 162, 236, 56, 24, 42, 205, 135, 175, 215,
			74, 29, 198, 122, 46, 48, 188, 79, 88, 190, 77, 19, 251, 138, 206,
			63, 1, 133, 233, 140, 32, 28, 170, 53, 38, 45, 180, 43, 59, 25,
			184, 181, 69, 168, 255, 71, 18, 229, 204, 80, 39, 22, 152, 11, 131,
			245, 145, 41, 178, 249, 31, 12, 134, 132, 117, 100, 26, 15, 230,
			124, 2, 4, 154, 148, 52, 78, 83, 239, 220, 177, 248, 129, 82, 6,
			250, 199, 14, 182, 207, 119, 33, 17, 111, 37, 130, 166, 76, 96, 13,
			126, 147, 174, 196, 235, 95, 157, 98, 150, 143, 137, 47, 221, 67,
			94, 161, 226, 241, 164, 156, 136, 203, 86, 120, 191, 34, 35, 54,
			108, 72, 113, 84, 112, 116, 186, 105, 232, 225, 228, 231, 21, 187,
			102, 64, 16, 91, 165, 200, 49, 247, 40, 242, 243, 51, 185, 253, 0,
			246, 222, 87, 158, 3, 121, 179, 58, 194, 107, 219, 208, 139, 99,
			23, 109, 159, 210, 171, 73, 213, 192, 234, 218, 60, 149, 183, 68,
			123, 223, 144, 118, 75, 195, 101, 128, 65, 106, 193, 216 };

		int* indicies = new int[ 256 ];

		memcpy( indicies, P, sizeof( int ) * 256 );

		return new Noise2D( indicies, gradients, gradients[ 0 ] );
	}


	Noise3D* create3D() const
	{
		FloatPoint3* gradients = new FloatPoint3[ 256 ];

		for ( int i=0; i<256; ++i )
		{
			gradients[ i ].x = drand48() * 2.0 - 1.0;
			gradients[ i ].y = drand48() * 2.0 - 1.0;
			gradients[ i ].z = drand48() * 2.0 - 1.0;

			float lengthSq = gradients[ i ].x * gradients[ i ].x
				+ gradients[ i ].y * gradients[ i ].y
				+ gradients[ i ].z * gradients[ i ].z;
			float length = sqrt( lengthSq );

			gradients[ i ].x /= length;
			gradients[ i ].y /= length;
			gradients[ i ].z /= length;
		}

		/*
		Offsets as generated by the following python code:

			import random
			values = [ str( x ) for x in range( 0, 256 ) ]
			random.seed( 0 )
			random.shuffle( values )
			print "{ %s }" % ", ".join( values )

		*/
		int P[256] = { 62, 211, 5, 167, 9, 20, 189, 30, 224, 93, 176, 110,
			155, 214, 50, 238, 81, 114, 104, 90, 151, 169, 160, 103, 197, 66,
			89, 85, 127, 55, 201, 172, 141, 10, 92, 70, 44, 163, 217, 212, 209,
			7, 125, 57, 36, 237, 254, 142, 97, 153, 227, 61, 27, 8, 146, 115,
			244, 173, 240, 252, 202, 162, 236, 56, 24, 42, 205, 135, 175, 215,
			74, 29, 198, 122, 46, 48, 188, 79, 88, 190, 77, 19, 251, 138, 206,
			63, 1, 133, 233, 140, 32, 28, 170, 53, 38, 45, 180, 43, 59, 25,
			184, 181, 69, 168, 255, 71, 18, 229, 204, 80, 39, 22, 152, 11, 131,
			245, 145, 41, 178, 249, 31, 12, 134, 132, 117, 100, 26, 15, 230,
			124, 2, 4, 154, 148, 52, 78, 83, 239, 220, 177, 248, 129, 82, 6,
			250, 199, 14, 182, 207, 119, 33, 17, 111, 37, 130, 166, 76, 96, 13,
			126, 147, 174, 196, 235, 95, 157, 98, 150, 143, 137, 47, 221, 67,
			94, 161, 226, 241, 164, 156, 136, 203, 86, 120, 191, 34, 35, 54,
			108, 72, 113, 84, 112, 116, 186, 105, 232, 225, 228, 231, 21, 187,
			102, 64, 16, 91, 165, 200, 49, 247, 40, 242, 243, 51, 185, 253, 0,
			246, 222, 87, 158, 3, 121, 179, 58, 194, 107, 219, 208, 139, 99,
			23, 109, 159, 210, 171, 73, 213, 192, 234, 218, 60, 149, 183, 68,
			123, 223, 144, 118, 75, 195, 101, 128, 65, 106, 193, 216 };

		int* indicies = new int[ 256 ];

		memcpy( indicies, P, sizeof( int ) * 256 );

		return new Noise3D( indicies, gradients, gradients[ 0 ] );
	}

};


}; // end namespace perlin 

#endif // PERLIN_H
